{
    "genNotice" : [
        "/*************************************************************************",
        "*     This Node Maya plugin was automatically generated by the Maya      *",
        "*                           generation wizard                            *",
        "*************************************************************************/"
    ],

    "includes": [
        "#include \"%_#_NODEINCLUDE_#_%\"",
        "#include <maya/MObject.h>",
        "#include <maya/MObjectArray.h>",
        "#include <maya/MString.h>",
        "#include <maya/MStringArray.h>",
        "#include <maya/MFnDependencyNode.h>",
        "#include <maya/MFnNumericAttribute.h>",
        "#include <maya/MFnCompoundAttribute.h>",
        "#include <maya/MFnEnumAttribute.h>",
        "#include <maya/MFnGenericAttribute.h>",
        "#include <maya/MFnMatrixAttribute.h>",
        "#include <maya/MFnMessageAttribute.h>",
        "#include <maya/MFnUnitAttribute.h>",
        "#include <maya/MGlobal.h>"
    ],

    "reqFns": [
        "// the type id used by the plugin",
        "const MTypeId %_#_CLASSNAME_#_%::m_typeId(0x70033);",
        "// the type name used by the plugin",
        "const MString %_#_CLASSNAME_#_%::m_typeName(\"%_#_CLASSNAME_#_%\");",
        "%_#_OBJDEC_#_%",
        "%_#_CLASSNAME_#_%::%_#_CLASSNAME_#_%()\n{\n\t// constructor\n}",
        "%_#_CLASSNAME_#_%::~%_#_CLASSNAME_#_%()\n{\n\t// destructor\n}",
        "void* %_#_CLASSNAME_#_%::creator()\n{\n\treturn new %_#_CLASSNAME_#_%;\n}\n",
        "MStatus %_#_CLASSNAME_#_%::compute(const MPlug &_plug, MDataBlock &_data)\n{\n\t// the main compute function, this is where the main functionality of the plugin goes\n\treturn MStatus::kSuccess;\n}",
        "MStatus %_#_CLASSNAME_#_%::initialize()\n{\n\t// function run when plugin initialized, put any init code here\n\tMStatus status;\n\n%_#_OBJINIT_#_%\n\n\treturn MStatus::kSuccess;\n}"
    ],

    "dependNodeFns": [
        "MStatus %_#_CLASSNAME_#_%::setDependentsDirty(const MPlug &_plugBeingDirtied, MPlugArray &_affectedPlugs )\n{\n\t// set any dirty flags here\n\treturn MStatus::kSuccess;\n}"
    ],

    "locatorNodeFns": [
        "void %_#_CLASSNAME_#_%::draw(M3dView &_view, const MDagPath &_path, M3dView::DisplayStyle _style, M3dView::DisplayStatus _status)\n{\n\t// this where the drawing of the locator node needs to be done\n}",
        "bool %_#_CLASSNAME_#_%::isBounded() const\n{\n\t// implement whether or not the node is bounded or not\n}",
        "MBoundingBox %_#_CLASSNAME_#_%::boundingBox() const\n{\n\t// implement the fetching of the bounding box\n}"
    ],

    "deformerNodeFns": [
        "MStatus %_#_CLASSNAME_#_%::deform(MDataBlock &_block, MItGeometry &_iter, const MMatrix &_mat, unsigned int _multiIndex)\n{\n\t// implement the deformation functionality here\n\treturn MStatus::kSuccess;\n}"
    ],

    "manipContainNodeFns": [
        "MStatus %_#_CLASSNAME_#_%::createChildren()\n{\n\t// creation of children to be implemented here\n\treturn MStatus::kSuccess;\n}",
        "MStatus %_#_CLASSNAME_#_%::connectToDependNode(const MObject &_node)\n{\n\t// implement connecting to depend node here\n\treturn MStatus::kSuccess;\n}",
        "void %_#_CLASSNAME_#_%::draw(M3dView &_view, const MDagPath &_path, M3dView::DisplayStyle _style, M3dView::DisplayStatus _status)\n{\n\t// this is where the drawing of the node needs to be implemented\n}"
    ],

    "ikSolveNodeFns": [
        "MStatus %_#_CLASSNAME_#_%::doSolve()\n{\n\t// implement the solving\n\treturn MStatus::kSuccess;\n}",
        "MString %_#_CLASSNAME_#_%::solverTypeName() const\n{\n\t// implement the return of the the solver type name\n}"
    ],

    "hwShaderNodeFns": [
        "void %_#_CLASSNAME_#_%::postConstructor()\n{\n\t// called after the constructor\n}",
        "MStatus %_#_CLASSNAME_#_%::bind(const MDrawRequest &_request, M3dView &_view)\n{\n\t// implement the binding of the node here\n\treturn MStatus::kSuccess;\n}",
        "MStatus %_#_CLASSNAME_#_%::unbind(const MDrawRequest &_request, M3dView &_view)\n{\n\t// implement the unbinding of the node here\n\treturn MStatus::kSuccess;\n}",
        "MStatus %_#_CLASSNAME_#_%::geometry(const MDrawRequest &_request, M3dView &_view, int _prim, unsigned int _writable,",
                                "\t\t\t\tint _indexCount, const unsigned int *_indexArray, int _vertexCount, const int *_vertexIDs,",
                                "\t\t\t\tconst float *_vertexArray, int _normalCount, const float **_normalArrays, int _colorCount,",
                                "\t\t\t\tconst float **_colorArrays, int _texCoordCount, const float **_texCoordArrays)\n{\n\t// the declaration of the geometry for the shader\n\treturn MStatus::kSuccess;\n}"
    ],

    "transformNodeFns": [
        "MPxTransformationMatrix *%_#_CLASSNAME_#_%::createTransformationMatrix()\n{\n\t// implement the creation of the transformation matrix\n}",
        "void %_#_CLASSNAME_#_%::postConstructor()\n{\n\t// called after the constructor\n}",
        "MStatus %_#_CLASSNAME_#_%::validateAndSetValue(const MPlug &_plug, const MDataHandle &_handle, const MDGContext &_context)\n{\n\t// implement validation and setting of values\n\treturn MStatus::kSuccess;\n}",
        "void %_#_CLASSNAME_#_%::resetTransformation (MPxTransformationMatrix *)\n{\n\t// implement the resetting of the transformation with a passed in transformation matrix\n}",
        "void %_#_CLASSNAME_#_%::resetTransformation (const MMatrix &)\n{\n\t// implement the resetting of the transformation with a standard matrix\n}"
    ],

    "imagePlaneNodeFns": [
        "MStatus %_#_CLASSNAME_#_%::loadImageMap( const MString &_fileName, int _frame, MImage &_image )\n{\n\t// here is where you will need to implement the loading of the image file\n\treturn MStatus::kSuccess;\n}",
        "bool %_#_CLASSNAME_#_%::getInternalValueInContext(const MPlug&, MDataHandle&,  MDGContext&)\n{\n\t// return the internal value based on the passed in context\n}",
        "bool %_#_CLASSNAME_#_%::setInternalValueInContext(const MPlug&, const MDataHandle&, MDGContext&)\n{\n\t// return the internal value based on the passed in context\n}"
    ],

    "constraintNodeFns": [
        "void %_#_CLASSNAME_#_%::postConstructor()\n{\n/t// called after the constructor is called\n}",
        "const MObject %_#_CLASSNAME_#_%::weightAttribute() const\n{\n\t// implement the fetching of the weight attribute\n}",
        "const MObject %_#_CLASSNAME_#_%::targetAttribute() const\n{\n\t// implement the fetching of the target attribute\n}",
        "void %_#_CLASSNAME_#_%::getOutputAttributes(MObjectArray &_attributeArray)\n{\n\t// implement getting the attributes output by the node\n}"
    ],

    "manipNodeFns": [
        "void %_#_CLASSNAME_#_%::draw(M3dView &_view, const MDagPath &_path,M3dView::DisplayStyle _style, M3dView::DisplayStatus _status)\n{\n\t// do all the drawing of the node here\n}",
        "MStatus %_#_CLASSNAME_#_%::doPress(M3dView &_view)\n{\n\t// implement what happens when the manip node is pressed\n\treturn MStatus::kSuccess;\n}",
        "MStatus %_#_CLASSNAME_#_%::doDrag(M3dView &_view)\n{\n\t// implement what happens when the manip node is dragged\n\treturn MStatus::kSuccess;\n}",
        "MStatus %_#_CLASSNAME_#_%::doRelease(M3dView &_view)\n{\n\t// implement what happens when the manip node is released\n\treturn MStatus::kSuccess;\n}",
        "MStatus %_#_CLASSNAME_#_%::connectToDependNode(const MObject &_dependNode)\n{\n\t// implement connecting to the passed in depend node here\n\treturn MStatus::kSuccess;\n}"
    ]
}
